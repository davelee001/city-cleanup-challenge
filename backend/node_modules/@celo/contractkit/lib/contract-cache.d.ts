import { IERC20 } from '@celo/abis/web3/IERC20';
import { Connection } from '@celo/connect';
import { AddressRegistry } from './address-registry';
import { CeloContract } from './base';
import { ContractCacheType } from './basic-contract-cache-type';
import { StableToken } from './celo-tokens';
import { Web3ContractCache } from './web3-contract-cache';
import { AccountsWrapper } from './wrappers/Accounts';
import { AttestationsWrapper } from './wrappers/Attestations';
import { ElectionWrapper } from './wrappers/Election';
import { EpochManagerWrapper } from './wrappers/EpochManager';
import { EpochRewardsWrapper } from './wrappers/EpochRewards';
import { Erc20Wrapper } from './wrappers/Erc20Wrapper';
import { EscrowWrapper } from './wrappers/Escrow';
import { FederatedAttestationsWrapper } from './wrappers/FederatedAttestations';
import { FeeCurrencyDirectoryWrapper } from './wrappers/FeeCurrencyDirectoryWrapper';
import { FreezerWrapper } from './wrappers/Freezer';
import { GoldTokenWrapper } from './wrappers/GoldTokenWrapper';
import { GovernanceWrapper } from './wrappers/Governance';
import { LockedGoldWrapper } from './wrappers/LockedGold';
import { MultiSigWrapper } from './wrappers/MultiSig';
import { OdisPaymentsWrapper } from './wrappers/OdisPayments';
import { ReserveWrapper } from './wrappers/Reserve';
import { ScoreManagerWrapper } from './wrappers/ScoreManager';
import { SortedOraclesWrapper } from './wrappers/SortedOracles';
import { StableTokenWrapper } from './wrappers/StableTokenWrapper';
import { ValidatorsWrapper } from './wrappers/Validators';
declare const WrapperFactories: {
    readonly Accounts: typeof AccountsWrapper;
    readonly EpochRewards: typeof EpochRewardsWrapper;
    readonly ERC20: typeof Erc20Wrapper;
    readonly Escrow: typeof EscrowWrapper;
    readonly FederatedAttestations: typeof FederatedAttestationsWrapper;
    readonly FeeCurrencyDirectory: typeof FeeCurrencyDirectoryWrapper;
    readonly Freezer: typeof FreezerWrapper;
    readonly GoldToken: typeof GoldTokenWrapper;
    readonly CeloToken: typeof GoldTokenWrapper;
    readonly MultiSig: typeof MultiSigWrapper;
    readonly OdisPayments: typeof OdisPaymentsWrapper;
    readonly Reserve: typeof ReserveWrapper;
    readonly ScoreManager: typeof ScoreManagerWrapper;
    readonly StableToken: typeof StableTokenWrapper;
    readonly StableTokenEUR: typeof StableTokenWrapper;
    readonly StableTokenBRL: typeof StableTokenWrapper;
};
declare const WithRegistry: {
    readonly SortedOracles: typeof SortedOraclesWrapper;
};
declare const WrapperFactoriesWhichNeedCache: {
    Attestations: typeof AttestationsWrapper;
    Election: typeof ElectionWrapper;
    EpochManager: typeof EpochManagerWrapper;
    Governance: typeof GovernanceWrapper;
    LockedCelo: typeof LockedGoldWrapper;
    LockedGold: typeof LockedGoldWrapper;
    Validators: typeof ValidatorsWrapper;
};
type CFType = typeof WrapperFactories;
type RegistryType = typeof WithRegistry;
type WrapperFactoriesWhichNeedCacheType = typeof WrapperFactoriesWhichNeedCache;
export type ValidWrappers = keyof CFType | keyof RegistryType | keyof WrapperFactoriesWhichNeedCacheType;
interface WrapperCacheMap {
    [CeloContract.Accounts]?: AccountsWrapper;
    [CeloContract.Attestations]?: AttestationsWrapper;
    [CeloContract.Election]?: ElectionWrapper;
    [CeloContract.EpochManager]?: EpochManagerWrapper;
    [CeloContract.EpochRewards]?: EpochRewardsWrapper;
    [CeloContract.ERC20]?: Erc20Wrapper<IERC20>;
    [CeloContract.Escrow]?: EscrowWrapper;
    [CeloContract.FederatedAttestations]?: FederatedAttestationsWrapper;
    [CeloContract.FeeCurrencyDirectory]?: FeeCurrencyDirectoryWrapper;
    [CeloContract.Freezer]?: FreezerWrapper;
    [CeloContract.CeloToken]?: GoldTokenWrapper;
    [CeloContract.GoldToken]?: GoldTokenWrapper;
    [CeloContract.Governance]?: GovernanceWrapper;
    [CeloContract.LockedCelo]?: LockedGoldWrapper;
    [CeloContract.LockedGold]?: LockedGoldWrapper;
    [CeloContract.MultiSig]?: MultiSigWrapper;
    [CeloContract.OdisPayments]?: OdisPaymentsWrapper;
    [CeloContract.Reserve]?: ReserveWrapper;
    [CeloContract.ScoreManager]?: ScoreManagerWrapper;
    [CeloContract.SortedOracles]?: SortedOraclesWrapper;
    [CeloContract.StableToken]?: StableTokenWrapper;
    [CeloContract.StableTokenEUR]?: StableTokenWrapper;
    [CeloContract.StableTokenBRL]?: StableTokenWrapper;
    [CeloContract.Validators]?: ValidatorsWrapper;
}
/**
 * Kit ContractWrappers factory & cache.
 *
 * Provides access to all contract wrappers for celo core contracts
 *
 * @remarks
 *
 * Because it provides access to all contract wrappers it must load all wrappers and the contract ABIs for them
 * Consider Using {@link MiniWrapperCache}, building your own, or if you only need one Wrapper using it directly
 */
export declare class WrapperCache implements ContractCacheType {
    readonly connection: Connection;
    readonly _web3Contracts: Web3ContractCache;
    readonly registry: AddressRegistry;
    private wrapperCache;
    constructor(connection: Connection, _web3Contracts: Web3ContractCache, registry: AddressRegistry);
    getAccounts(): Promise<AccountsWrapper>;
    getAttestations(): Promise<AttestationsWrapper>;
    getElection(): Promise<ElectionWrapper>;
    getEpochRewards(): Promise<EpochRewardsWrapper>;
    getEpochManager(): Promise<EpochManagerWrapper>;
    getErc20(address: string): Promise<Erc20Wrapper<IERC20>>;
    getEscrow(): Promise<EscrowWrapper>;
    getFreezer(): Promise<FreezerWrapper>;
    getFederatedAttestations(): Promise<FederatedAttestationsWrapper>;
    getFeeCurrencyDirectory(): Promise<FeeCurrencyDirectoryWrapper>;
    getGoldToken(): Promise<GoldTokenWrapper>;
    getCeloToken(): Promise<GoldTokenWrapper>;
    getGovernance(): Promise<GovernanceWrapper>;
    getLockedGold(): Promise<LockedGoldWrapper>;
    getLockedCelo(): Promise<LockedGoldWrapper>;
    getMultiSig(address: string): Promise<MultiSigWrapper>;
    getOdisPayments(): Promise<OdisPaymentsWrapper>;
    getReserve(): Promise<ReserveWrapper>;
    getScoreManager(): Promise<ScoreManagerWrapper>;
    getSortedOracles(): Promise<SortedOraclesWrapper>;
    getStableToken(stableToken?: StableToken): Promise<StableTokenWrapper>;
    getValidators(): Promise<ValidatorsWrapper>;
    /**
     * Get Contract wrapper
     */
    getContract<C extends ValidWrappers>(contract: C, address?: string): Promise<NonNullable<WrapperCacheMap[C]>>;
    invalidateContract<C extends ValidWrappers>(contract: C): void;
}
export {};
